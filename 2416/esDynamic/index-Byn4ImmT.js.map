{"version":3,"file":"index-Byn4ImmT.js","sources":["../../src/fixtures/hilight/api/hilight-mode/base-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/lift-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/fog-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/glow-hilight-mode.ts","../../src/fixtures/hilight/api/hilight.ts","../../src/fixtures/hilight/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport {\n    APIScope,\n    CommonGraphicLayer,\n    InstanceAPI,\n    LayerInstance\n} from '@/api';\nimport { HilightMode, HILIGHT_LAYER_NAME } from '../hilight-defs';\nimport type { Graphic } from '@/geo/api';\n\n/**\n * Base mode for hilighter modes. On its own, this mode will not hilight anything.\n */\nexport class BaseHilightMode extends APIScope {\n    config: any = {};\n    mode: HilightMode = HilightMode.NONE;\n\n    constructor(config: any, iApi: InstanceAPI) {\n        super(iApi);\n        this.config = config;\n        this.mode = config.mode;\n    }\n\n    /**\n     * Adds the given graphics to the hilighter.\n     *\n     * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to hilight\n     * @returns {Promise} resolves when graphics have been added\n     */\n    async add(graphics: Array<Graphic> | Graphic): Promise<void> {\n        this.notImplementedError('addGraphics');\n    }\n\n    /**\n     * Removes the given graphics from the hilighter. No parmeter removes all graphics.\n     *\n     * @param {Graphic | Array<Graphic> | undefined} graphics one or more RAMP Graphics to remove\n     * @returns {Promise} resolves when graphics have been added\n     */\n    async remove(\n        graphics: Array<Graphic> | Graphic | undefined\n    ): Promise<void> {\n        this.notImplementedError('removeGraphics');\n    }\n\n    /**\n     * Reload the provided graphics that are currently highlighted.\n     *\n     * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to reload\n     * @returns {Promise} resolves when graphics have been reloaded\n     */\n    async reloadHilight(graphics: Array<Graphic> | Graphic): Promise<void> {\n        this.notImplementedError('reloadHilight');\n    }\n\n    /**\n     * Returns the Hilight layer, if it exists.\n     *\n     * @returns {Promise<CommonGraphicLayer | undefined>}\n     */\n    async getHilightLayer(): Promise<CommonGraphicLayer | undefined> {\n        const hilightLayer = await this.layerFetcher();\n        if (hilightLayer) {\n            if (\n                hilightLayer.isLoaded &&\n                hilightLayer instanceof CommonGraphicLayer\n            ) {\n                return hilightLayer;\n            } else {\n                console.warn('Hilight layer exists but is in bad form.');\n                return undefined;\n            }\n        } else {\n            console.warn('Hilight layer could not be fetched.');\n            return undefined;\n        }\n    }\n\n    private notImplementedError(method: string) {\n        console.warn(\n            `Hilight mode method ${method} was not implemented by subclass.`\n        );\n    }\n\n    /**\n     * Provides a short grace period to avoid scenarios where the layer is still getting created.\n     * Not overly long, as the highlight layer is a local graphics layer so no server lag involved.\n     *\n     * @returns Promise resolving in the LayerInstace, or undefined if we could not locate the layer.\n     */\n    private layerFetcher(): Promise<LayerInstance | undefined> {\n        // code duplication, but lets us avoid a 125ms delay on the initial check. Once layer\n        // is loaded that's wasted time.\n        const precheckLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\n        if (precheckLayer) {\n            return Promise.resolve(precheckLayer);\n        } else {\n            return new Promise(resolve => {\n                let timeElapsed = 0;\n\n                const layerWatcher = setInterval(() => {\n                    const layer =\n                        this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\n                    if (layer) {\n                        clearInterval(layerWatcher);\n                        resolve(layer);\n                    } else {\n                        // layer was not found, take a nap\n                        timeElapsed += 125;\n                        if (timeElapsed >= 1125) {\n                            // to long, game over\n                            clearInterval(layerWatcher);\n                            resolve(undefined);\n                            return;\n                        }\n                    }\n                }, 125);\n            });\n        }\n    }\n}\n","import type { Graphic } from '@/geo/api';\nimport { BaseHilightMode } from './base-hilight-mode';\n\n/**\n * Hilight mode that places graphics in a top-most layer, essentially \"lifting\" them\n * above other map elements.\n */\nexport class LiftHilightMode extends BaseHilightMode {\n    async add(graphics: Array<Graphic> | Graphic) {\n        const hilightLayer = await this.getHilightLayer();\n        if (!hilightLayer) {\n            return;\n        }\n        await hilightLayer.addGraphic(graphics);\n    }\n\n    async remove(graphics: Array<Graphic> | Graphic | undefined) {\n        const hilightLayer = await this.getHilightLayer();\n        if (!hilightLayer) {\n            return;\n        }\n        hilightLayer.removeGraphic(graphics);\n    }\n\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\n        await this.remove(graphics);\n        await this.add(graphics);\n    }\n}\n","import { GlobalEvents, type InstanceAPI, TileLayer } from '@/api';\nimport { type Graphic, LayerType, type RampBasemapConfig } from '@/geo/api';\nimport { useConfigStore } from '@/stores/config';\nimport { FOG_HILIGHT_LAYER_NAME } from '../hilight-defs';\nimport { LiftHilightMode } from './lift-hilight-mode';\n\n/**\n * Hilight mode that places a translucent tile beneath a graphics to make them\n * stand out from the rest of the map.\n */\nexport class FogHilightMode extends LiftHilightMode {\n    handlers: Array<string> = [];\n    // TODO: make these configurable later\n    // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1353\n    onOpacity: number;\n    offOpacity: number;\n\n    private lastAdd: number = 0;\n\n    constructor(config: any, iApi: InstanceAPI) {\n        super(config, iApi);\n        this.onOpacity = config.options?.onOpacity ?? 0.75;\n        this.offOpacity =\n            config.options?.offOpacity > 0.02\n                ? config.options.offOpacity\n                : 0.02;\n\n        if (this.$iApi.geo.map.created) {\n            this.hilightSetup();\n        } else {\n            this.handlers.push(\n                this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {\n                    this.hilightSetup();\n                })\n            );\n        }\n\n        this.handlers.push(\n            this.$iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, () => {\n                this.getHilightLayer().then(hilightLayer => {\n                    if (hilightLayer && hilightLayer.graphics.length === 0) {\n                        // if the highlighter is currently \"off\", update the basemap\n                        // if the highlighter is \"on\", then details (or whatever is using the hilighter) will handle this event\n                        this.updateFogLayer();\n                    }\n                });\n            })\n        );\n    }\n\n    private async hilightSetup() {\n        const mapConfig: RampBasemapConfig = useConfigStore(this.$vApp.$pinia)\n            .activeBasemapConfig as RampBasemapConfig;\n        try {\n            const fogLayer = this.$iApi.geo.layer.createLayer({\n                id: FOG_HILIGHT_LAYER_NAME,\n                layerType: LayerType.TILE,\n                cosmetic: true,\n                // TODO: what if there's more than 1 URL provided?\n                // See https://github.com/ramp4-pcar4/ramp4-pcar4/discussions/1352\n                url: mapConfig.layers[0].url\n            });\n\n            await this.$iApi.geo.map.addLayer(fogLayer);\n            // off\n            fogLayer.opacity = this.offOpacity;\n\n            await this.reorderFogLayer();\n        } catch {\n            console.error(\n                'Something went wrong while setting up the hilighter.'\n            );\n        }\n    }\n\n    private async updateFogLayer() {\n        this.$iApi.geo.map.removeLayer(FOG_HILIGHT_LAYER_NAME);\n        await this.hilightSetup();\n    }\n\n    private async reorderFogLayer() {\n        const fogLayer = this.getFogLayer();\n        const hilightLayer = await this.getHilightLayer();\n        if (!hilightLayer || !fogLayer) {\n            return;\n        }\n\n        const layerOrder = this.$iApi.geo.layer.layerOrderIds();\n        const fogIdx = layerOrder.indexOf(fogLayer.id);\n        const hilightIdx = layerOrder.indexOf(hilightLayer.id);\n\n        if (hilightIdx < fogIdx && hilightIdx > -1 && fogIdx > -1) {\n            // No +1. Since highlight is below, fog will get pushed down\n            // as things shift.\n            this.$iApi.geo.map.reorder(hilightLayer, fogIdx, false);\n        }\n    }\n\n    async add(graphics: Array<Graphic> | Graphic) {\n        this.lastAdd = Date.now();\n\n        // turn the fog \"on\"\n        const fogLayer = this.getFogLayer();\n        if (!fogLayer) {\n            return;\n        }\n        fogLayer.opacity = this.onOpacity;\n\n        // add the given graphics to the layer\n        await super.add(graphics);\n    }\n\n    async remove(graphics?: Array<Graphic> | Graphic | undefined) {\n        // remove the given graphics from the layer\n        await super.remove(graphics);\n\n        // NOTE: because details calls remove and add each time it does a hilight, there can be a flicker\n        // when switching between items on the details panel (because the fog gets turned off then on again each time)\n        // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1350\n\n        // turn the fog \"off\"\n        const fogLayer = this.getFogLayer();\n        if (!fogLayer) {\n            return;\n        }\n\n        // When we quickly go from highlighting one item to another, if it's the first time\n        // highlighting we can have a delay if RAMP needs to fetch feature attribute data\n        // from a map server. This can cause a \"flicker\" on the screen as the fog layer turns\n        // off then turns back on again.\n        // This timeout will give a small time buffer to give a new highlight a chance\n        // to be requested. If we see that one was, we will not turn off and\n        // simply wait for next add to finish.\n        const lastRemove = Date.now();\n        const hilightLayer = await this.getHilightLayer();\n        if (!hilightLayer) {\n            return;\n        }\n        setTimeout(() => {\n            if (this.lastAdd < lastRemove && !hilightLayer.getGraphicCount()) {\n                // nothing was added during the timeout AND there is nothing\n                // currently hilighted, so we turn off the fog\n                fogLayer.opacity = this.offOpacity;\n            }\n        }, 300);\n    }\n\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\n        await this.updateFogLayer();\n        await super.reloadHilight(graphics);\n    }\n\n    /**\n     * Returns the \"fog\" tile layer.\n     */\n    private getFogLayer(): TileLayer | undefined {\n        const hilightLayer = this.$iApi.geo.layer.getLayer(\n            FOG_HILIGHT_LAYER_NAME\n        );\n        if (hilightLayer && hilightLayer instanceof TileLayer) {\n            return hilightLayer;\n        } else {\n            console.warn('Hilight fog layer could not be fetched.');\n            return undefined;\n        }\n    }\n}\n","import { InstanceAPI, GraphicLayer, GlobalEvents } from '@/api';\nimport type { Graphic } from '@/geo/api';\nimport { HILIGHT_LAYER_NAME } from '../hilight-defs';\nimport { LiftHilightMode } from './lift-hilight-mode';\n\n/**\n * Hilight mode that lifts graphics and applies a glow outline to make them\n * stand out from the rest of the map.\n */\nexport class GlowHilightMode extends LiftHilightMode {\n    handlers: Array<string> = [];\n\n    constructor(config: any, iApi: InstanceAPI) {\n        super(config, iApi);\n\n        this.hilightSetup(config);\n\n        this.handlers.push(\n            this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {\n                this.hilightSetup(config);\n            })\n        );\n    }\n\n    private hilightSetup(config: any) {\n        this.$iApi.geo.map.viewPromise.then(() => {\n            this.$iApi.geo.map.esriView!.highlightOptions = config.options;\n        });\n    }\n\n    async add(graphics: Array<Graphic> | Graphic) {\n        // add the given graphics to the layer\n        await super.add(graphics);\n\n        // apply the esri highlight to the graphics\n        const hilightLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\n        if (\n            hilightLayer &&\n            hilightLayer.esriLayer &&\n            hilightLayer.isLoaded &&\n            hilightLayer instanceof GraphicLayer\n        ) {\n            const gs = graphics instanceof Array ? graphics : [graphics];\n            this.$iApi.geo.map.esriView\n                ?.whenLayerView(hilightLayer.esriLayer)\n                ?.then(function (layerView) {\n                    layerView.highlight(\n                        gs.map(g => hilightLayer.getEsriGraphic(g.id)!)\n                    );\n                });\n        }\n    }\n\n    async remove(graphics?: Array<Graphic> | Graphic | undefined) {\n        await super.remove(graphics);\n        // removing the graphic will also remove the esri highlight\n        // so there's nothing else to do here\n        return;\n    }\n}\n","import { CommonGraphicLayer, FixtureInstance } from '@/api/internal';\nimport { Graphic, LayerType } from '@/geo/api';\nimport {\n    DEFAULT_CONFIG,\n    HILIGHT_LAYER_NAME,\n    HilightMode,\n    type HilightConfig\n} from './hilight-defs';\nimport { BaseHilightMode } from './hilight-mode/base-hilight-mode';\nimport { FogHilightMode } from './hilight-mode/fog-hilight-mode';\nimport { GlowHilightMode } from './hilight-mode/glow-hilight-mode';\nimport { LiftHilightMode } from './hilight-mode/lift-hilight-mode';\n\n/**\n * Exposes methods to manage the hilighting of features on the map\n */\nexport class HilightAPI extends FixtureInstance {\n    hilightMode: BaseHilightMode = new BaseHilightMode({}, this.$iApi);\n\n    initialized(): void {\n        // create the highlight layer once the map is available\n        this.initHilightLayer();\n    }\n\n    _parseConfig(hilightConfig?: HilightConfig) {\n        if (hilightConfig) {\n            switch (hilightConfig.mode) {\n                case HilightMode.NONE:\n                    this.hilightMode = new BaseHilightMode(\n                        hilightConfig,\n                        this.$iApi\n                    );\n                    break;\n                case HilightMode.GLOW:\n                    this.hilightMode = new GlowHilightMode(\n                        hilightConfig,\n                        this.$iApi\n                    );\n                    break;\n                case HilightMode.LIFT:\n                    this.hilightMode = new LiftHilightMode(\n                        hilightConfig,\n                        this.$iApi\n                    );\n                    break;\n                case HilightMode.FOG:\n                    this.hilightMode = new FogHilightMode(\n                        hilightConfig,\n                        this.$iApi\n                    );\n                    break;\n                default:\n                    // in this case, the hilighter will use NONE (BaseHilightMode)\n                    console.error(\n                        'Could not find hilight mode:',\n                        hilightConfig.mode\n                    );\n                    break;\n            }\n        } else {\n            // defaults to GLOW\n            this.hilightMode = new GlowHilightMode(DEFAULT_CONFIG, this.$iApi);\n        }\n    }\n\n    /**\n     * Initialize the Hilight layer.\n     *\n     * @returns {Promise} resolves when layer is initialized\n     */\n    async initHilightLayer(): Promise<void> {\n        const hilightLayer = this.$iApi.geo.layer.createLayer({\n            id: HILIGHT_LAYER_NAME,\n            layerType: LayerType.GRAPHIC,\n            cosmetic: true,\n            url: ''\n        });\n\n        await this.$iApi.geo.map.addLayer(hilightLayer);\n    }\n\n    /**\n     * Add the given Graphics to the Hilighter\n     *\n     * @param {Graphic | Array<Graphic>} graphics Graphics to add\n     * @returns {Promise} resolves when graphics have been added\n     */\n    async addHilight(graphics: Array<Graphic> | Graphic): Promise<void> {\n        const gs = graphics instanceof Array ? graphics : [graphics];\n        await this.hilightMode.add(gs);\n    }\n\n    /**\n     * Remove the given Graphics from the Hilighter. If no graphics are provided,\n     * all highlighted items will be removed.\n     *\n     * @param {Graphic | Array<Graphic> | undefined} graphics Graphics to remove\n     * @returns {Promise} resolves when graphics have been removed\n     */\n    async removeHilight(graphics?: Array<Graphic> | Graphic): Promise<void> {\n        const gs = graphics\n            ? graphics instanceof Array\n                ? graphics\n                : [graphics]\n            : undefined;\n        await this.hilightMode.remove(gs);\n    }\n\n    /**\n     * Reload the provided graphics that are currently highlighted.\n     *\n     * @param {Array<Graphic> | Graphic} graphics\n     */\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\n        const gs = graphics instanceof Array ? graphics : [graphics];\n        await this.hilightMode.reloadHilight(gs);\n    }\n\n    /**\n     * Return all Graphics that match the given origin/uid/oid\n     *\n     * @param origin Graphic origin\n     * @param uid Associated layer UID of the Graphic\n     * @param oid Associated OID of the Graphic\n     */\n    async getGraphicsByKey(\n        origin?: string,\n        uid?: string,\n        oid?: number\n    ): Promise<Array<Graphic>> {\n        const hilightLayer = await this.getHilightLayer();\n        if (!hilightLayer) {\n            return [];\n        }\n\n        let keys = hilightLayer.graphics.map(g => ({\n            ...this.deconstructGraphicKey(g.id),\n            og: g\n        }));\n\n        if (origin) {\n            keys = keys.filter(k => k.origin === origin);\n        }\n\n        if (uid) {\n            keys = keys.filter(k => k.uid === uid);\n        }\n\n        if (oid) {\n            keys = keys.filter(k => k.oid === oid);\n        }\n\n        return keys.map(k => k.og);\n    }\n\n    /**\n     * Return a well-formed graphic key\n     */\n    constructGraphicKey(origin: string, uid: string, oid: number): string {\n        return `${HILIGHT_LAYER_NAME}~${origin}~${uid}~${oid}`;\n    }\n\n    /**\n     * Return a deconstructed graphic key.\n     *\n     * @param key The graphic key to deconstruct\n     */\n    deconstructGraphicKey(key: string): {\n        origin: string;\n        uid: string;\n        oid: number;\n    } {\n        const ids = key.split('~');\n        if (ids.length !== 4) {\n            console.warn('Malformed Hilight Graphic key provided:', key);\n        }\n        return { origin: ids[1], uid: ids[2], oid: parseInt(ids[3]) };\n    }\n\n    /**\n     * Return the hilightLayer\n     */\n    async getHilightLayer(): Promise<CommonGraphicLayer | undefined> {\n        if (this.hilightMode) {\n            return await this.hilightMode.getHilightLayer();\n        } else {\n            console.warn(\n                'API get layer request before highlight mode object exists'\n            );\n            return undefined;\n        }\n    }\n}\n","import { HilightAPI } from './api/hilight';\n\nclass HilightFixture extends HilightAPI {\n    async added() {\n        // console.log(`[fixture] ${this.id} added`);\n\n        this._parseConfig(this.config);\n        const unwatch = this.$vApp.$watch(\n            () => this.config,\n            (value: any) => this._parseConfig(value)\n        );\n\n        // override the removed method here to get access to scope\n        this.removed = () => {\n            // console.log(`[fixture] ${this.id} removed`);\n            unwatch();\n        };\n    }\n}\n\nexport default HilightFixture;\n"],"names":["BaseHilightMode","APIScope","HilightMode","config","iApi","graphics","hilightLayer","CommonGraphicLayer","method","precheckLayer","HILIGHT_LAYER_NAME","resolve","timeElapsed","layerWatcher","layer","LiftHilightMode","FogHilightMode","GlobalEvents","mapConfig","useConfigStore","fogLayer","FOG_HILIGHT_LAYER_NAME","LayerType","layerOrder","fogIdx","hilightIdx","lastRemove","TileLayer","GlowHilightMode","GraphicLayer","gs","layerView","g","HilightAPI","FixtureInstance","hilightConfig","DEFAULT_CONFIG","origin","uid","oid","keys","k","key","ids","HilightFixture","unwatch","value"],"mappings":"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"}